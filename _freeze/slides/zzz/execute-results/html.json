{
  "hash": "327a4eb18ed50eb403f5a70ba56b4dc6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: zzz\nformat: minimal-revealjs\n---\n\n## Latent formulation of the binomial model\n\nTo clarify a little bit the terminology the *logit* function (link function $g(\\cdot)$) is:\n\n$$\nq = \\log{\\frac{p}{1 - p}}\n$$\n\nThe inverse of the logit is called *logistic* (inverse link function $g^{-1}(\\cdot)$) function:\n\n$$\np = \\frac{e^p}{1 + e^p}\n$$\n\n## Latent formulation of the binomial model\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](zzz_files/figure-revealjs/unnamed-chunk-1-1.svg)\n:::\n:::\n\n\n## Latent formulation of the binomial model\n\n- Instead of thinking about a binary variable, you can think about e.g. accuracy as a continous measure from $-\\infty$ to $+\\infty$. \n- Then you can imagine to cut this continous measure using a threshold. Everthing above the threshold takes the value 1 otherwise 0.\n- Using the *logit* function we are assuming that this underlying *latent* variable is a standard **logistic** distribution.\n- The standard logistic distribution is a continous variable (similar to the Gaussian) with mean $\\mu = 0$ and $\\sigma^2 = \\frac{s^2 \\pi^2}{3}$. Given that $s^2 = 1$ in the standard logistic distribution the variance is $\\frac{\\pi^2}{3}$.\n\n::: aside\n[https://en.wikipedia.org/wiki/Logistic_distribution](https://en.wikipedia.org/wiki/Logistic_distribution)\n:::\n\n## Latent formulation of the binomial model\n\nYou can draw the logistic distribution using `dlogis()`. The comulative distribution function `plogis()` is the *logistic* function and the quantile function `qlogis()` is the *logit* function.\n\n## Latent formulation of the binomial model\n\nIn this framework, saying that the logit in one condition is 0 means that the probability is 0.5 thus 50% of the observations are expected to have a value of 1 and 50% a value of 0.\n\nBy moving the mean of the latent logistic distribution we are assinassignigng ing more probability to 1 or to 0.\n\n## ciao\n\nA shift in the latent distribution represents also a shift in the proportions of 1 and 0. Regression coefficients (in logit) represent the shift in the latent distribution and odds ratios are the shift in the odds/proportions.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](zzz_files/figure-revealjs/unnamed-chunk-2-1.svg)\n:::\n:::\n\n\n\n## Latent formulation of the binomial model\n\nIn other terms, the logistic regression can be expressed as a linear model predicting shifts in the mean of the logistic distribution as a functions of predictors as in standard linear models assuming normality.\n\nThe parameters $\\beta$ are shifts in the underlying latent distribution. $\\beta = 1$ is like saying that the difference between the groups is 1 standard deviation on the latent scale.\n\n## Latent formulation of the binomial model\n\nPractically this means that we can write the same model in the latent form:\n\n$$\nz_i = \\beta_0 + \\beta_1 x_i + \\epsilon_i\n$$\n\n$$\n\\epsilon_i \\sim \\mbox{Logistic}(0, 1)\n$$\n\nWhere $z_i$ is the latent value (e.g., logit). Errors are distributed according to a standard logistic distribution.\n\nThen the observed 0-1 values:\n\n$$\n\\begin{cases}\n1 & \\text{if } z_i > 0, \\\\\n0 & \\text{if } z_i \\le 0 .\n\\end{cases}\n$$\n\n## Latent formulation of the binomial model\n\nIn R we can show this very easily. We can simulate a latent shift and the corresponding pattern in probabilities using the standard and latent form of the logistic regression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- 0.5 # probability of group 1\np2 <- 0.8 # probability of group 2\n(d <- qlogis(p2) - qlogis(p1)) # latent shift, log odds ratio\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.386294\n```\n\n\n:::\n\n```{.r .cell-code}\n(or <- exp(d)) # odds ratio\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n## Latent formulation of the binomial model\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# number of observations, large to show the pattern\nn <- 10000\n\n# using rbinom\nx <- rep(0:1, each = n/2) # condition 1 and condition 2\np <- plogis(qlogis(p1) + d * x)\nyb <- rbinom(n, 1, p)\n\n# latent form\nz <- qlogis(p1) + x * d + rlogis(n, 0, 1)\nyl <- ifelse(z > 0, 1, 0)\n\ntapply(yb, x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     0      1 \n0.4968 0.7966 \n```\n\n\n:::\n\n```{.r .cell-code}\ntapply(yl, x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     0      1 \n0.4934 0.7982 \n```\n\n\n:::\n:::\n\n\n## Latent formulation of the binomial model\n\nThe beauty of the latent intepretation is that if you change the error part from a logistic to a gaussian distribution, you obtain the **probit** model.\n\nIn the probit the idea is the same but shifts are in units of a standard normal distribution that can be intepreted as Cohen's $d$.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "zzz_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}